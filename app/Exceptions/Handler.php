<?php

namespace App\Exceptions;

use App\Api\Helpers\ExceptionReport;
use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;
use Throwable;

class Handler extends ExceptionHandler
{
    /**
     * 按类型忽略异常
     * 不会被报告的异常类型列表
     *
     * @var array<int, class-string<\Throwable>>
     */
    protected $dontReport = [
//        InvalidOrderException::class,
    ];

    /**
     * 父类中默认的不需要报告的异常
     *
     * protected $internalDontReport = [
     * AuthenticationException::class, // 认证相关的异常
     * AuthorizationException::class, // 授权相关的异常
     * BackedEnumCaseNotFoundException::class, //
     * HttpException::class, // HTTP 相关的异常
     * HttpResponseException::class, // HTTP 响应相关的异常
     * ModelNotFoundException::class, // 模型不存在的异常
     * MultipleRecordsFoundException::class,
     * RecordsNotFoundException::class,
     * SuspiciousOperationException::class,
     * TokenMismatchException::class, // Token 不匹配的异常
     * ValidationException::class, // 表单验证异常
     * ];
     */

    /**
     * The list of the inputs that are never flashed to the session on validation exceptions.
     *
     * @var array<int, string>
     */
    protected $dontFlash = [
        'current_password',
        'password',
        'password_confirmation',
    ];

    /**
     * 为应用程序注册异常处理回调
     */
    public function register(): void
    {
        $this->reportable(function (Throwable $e) {
            //
        });
    }

    /**
     * 报告或记录一个异常，这是个给 Bugsnag 或 Sentry 发送异常的好地方
     *
     * 用于记录异常或将它们发送给如 Bugsnag 或 Sentry 等外部服务
     * 默认情况下，report 方法将异常传递给记录异常的基类
     * 不过，你可以使用任何自己喜欢的方式来记录异常
     *
     * 例如，如果你需要以不同方式报告不同类型的异常，则可以使用 PHP instanceof 比较运算符
     *
     * @param Throwable $e
     * @return void
     * @throws Throwable
     */
    public function report(Throwable $e)
    {
        return parent::report($e); // TODO: Change the autogenerated stub

        // $e = $this->mapException($e);
        //
        //        if ($this->shouldntReport($e)) {
        //            return;
        //        }
        //
        //        $this->reportThrowable($e);
    }

    /**
     * 负责将给定的异常转换为将被发送回浏览器的 HTTP 响应
     * 默认情况下，异常将传递给为你生成响应的基类
     * 不过，你可以按自己意愿检查异常类型或返回自己的自定义响应
     *
     * @param $request
     * @param Throwable $e
     * @return \Illuminate\Http\JsonResponse|\Illuminate\Http\RedirectResponse|\Illuminate\Http\Response|\Symfony\Component\HttpFoundation\Response|null
     * @throws Throwable
     */
    public function render($request, Throwable $e)
    {
        // ajax 请求才捕捉异常
        if ($request->ajax()) {
            $e = $this->mapException($e);

            // 将方法拦截到自己的 ExceptionReport
            $reporter = ExceptionReport::make($e);

            if ($reporter->shouldReturn()) {
                return $reporter->report();
            }

            if (config('app.debug')) {
                // 开发环境，显示详细错误信息
                return parent::render($request, $e);
            } else {
                // 线上环境，未知错误，则显示500
                return $reporter->prodReport();
            }
        }

        /**
         * Symfony\Component\ErrorHandler\Error\FatalError: Class App\Services\Auth\ApiGuardOld contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (Illuminate\Contracts\Auth\StatefulGuard::login) in file /var/www/html/app/Services/Auth/ApiGuardOld.php on line 9
         *
         * #0 {main}
         */

        dd($e);
//        dd($e->getFile() . '(' . $e->getLine() . ')' . ': ' . $e->getMessage());
//        dd($e->getMessage(), $e->getFile(), $e->getLine(), $e->getTrace(), $e->getTraceAsString(), $e->getPrevious());
//        $this->report($e);
        return parent::render($request, $e); // TODO: Change the autogenerated stub
    }
}
